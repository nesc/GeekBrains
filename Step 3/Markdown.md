# Разработать модуль "Информационное окно клиента" для .net приложения из области банковской системы.
## Модуль будет использоваться специалистами по поддержке клиентов для получения общей информации о клиенте и его продуктах в банке.

1. Модуль должен работать как клиент-серверное приложение.
2. Модуль должен по входным данным получать всю необходимую информацию при ее наличии и передавать консолидированные данные.
3. Модуль будет являться агрегатором данных:
	- По клиенту (ФИО, адрес, контактный номер и т.п.)
	- По счетам (Номер счета, остаток)
	- По открытым продуктам (номер договора, дата открытия (кредит, депозит))
4. Модуль не должен иметь конкретной реализации под программное окружение. Вместо этого нужно иметь коннекторы ORM для подключения к окружению (к базе данных источника; типу базы, на примере Diasoft Fa# ; для базы данных модуля, где хранится информация с меткой даты обновления).
5. Если модуль не может установить соединение с источником - берет информацию из базы данных модуля но предупреждает о том, что данные от старой даты. 

## InfoClient - Название модуля
- **Client** - Карточка клиента содержащая общую информацию о клиенте
- **Account** - Банковский счет клиента
- **Credit** - Кредит открытый в банке
- **AbsDB** - База данных банковской системы
- **InfoClientDB** - База данных разрабатываемого модуля

## **Client**
- ClientID (идентификатор для связей)
- FIO (Фамилия имя отчество)
- Birthdate (Дата рождения)
- Document (Документ удостоверяющий личность)
- Address (Адрес без разбивки на сущности)
- Telephon (Контактный телефон)

## **Account**
- AccountID (идентификатор для связей)
- ClientID (идентификатор для связей)
- AccountNumber (Номер счета)
- Rest (Остаток)
- DateRest (Дата остатка)

## **Credit**
- CreditID (идентификатор для связей)
- ClientID (идентификатор для связей)
- CreditNumber (Номер кредитного договора)
- CreditAmount (Сумма кредита)
- CreditDate (Дата выдачи кредита)

## **Deposit**
- DepositID (идентификатор для связей)
- ClientID (идентификатор для связей)
- DepositNumber (Номер депозитного договора)
- DepositAmount (Сумма депозита)
- DepositDate (Дата выдачи депозита)

## **AbsDB**
- AbsDBHostname (Имя сервера базы данных источника)
- AbsDBName (Имя базы данных источника)
- AbsDBUser (Интеграционный пользователь для загрузки данных)
- AbsDBPassword (Пароль интеграционного пользователя)

## **InfoClientDB**
- InfoClientDBHostname (Имя сервера базы данных модуля)
- InfoClientDBName (Имя базы данных модуля)
- InfoClientDBUser (Пользователь для сохранения данных в базе данных модуля)
- InfoClientDBPassword (Пароль пользователя для сохранения данных в базе данных модуля)

## **Описание связей**
- **Client** связан с счетом **Account** через **ClientID**
- **Client** связан с счетом **Credit** через **ClientID**
- **Client** связан с счетом **Deposit** через **ClientID**
- **AbsDB** - это настройки для подключения к базе данных источника
- **InfoClientDB** - это настройки для подключения к базе данных модуля

# Описание работы
- Все сущности загружаются из источника либо из базы данных модуля при отсутствии соединения с источником. Реализация подключения к базам данных источника и модуля через ORM. Не смог понять как это в коде отразить. В моем небольшом опыте программирования не было ORM.
- База данных источника для моего примера будет MS SQL Server, но ORM позволит быстро настроить подключение на другие СУБД.
- Базу данных модуля мы можем выбирать исходя из потребностей. А потребности простые. Нужно использовать базу данных модуля только как хранилище. И для этого я бы хотел использовать прежде всего бесплатное решение, не малоизвестное в случае если будут вопросы к реализации. Тогда я смогу найти примеры решения своих задач. Мне не так важна консистентность, потому как я получаю данные из системы источника почти в тот момент, что и после запрашиваю их. И мне не важно иметь данные предыдущих запросов. Все это позволяет сделать распределенную БД с высоким показателем доступности. Я считаю, что могу взять базу данных для модуля - **Cassandra**. Она топ 11 в рейтинге и обладает важными для моей архитектуры свойствами. Такими как Распределенность БД. Асинхронность взаимодействия с разными ЦОД. Отказоустойчивость. Отсутствие необходимости соблюдения целостности с ранними запросами. Достаточно обрабатывать текущий запрос в одном ЦОД.

# Задание с выбором API.
Я считаю, что для моего модуля приложения подойдет **REST** . Попробую его описать.

- По POST-запросу на URL-адрес **server-name.com/InfoClient** реализовано получение запроса на поиск информации по ID клиента.
	При вызове этого запроса я ожидаю, что будет запущена функция LoadInfo() в классе InfoClient.
- По GET-запросу на URL-адрес **server-name.com/InfoClientResponse** реализован возврат ответа по ранее запрошенному сбору информации по клиенту.
	При вызове этого запроса я ожидаю, что будет запущена функция LoadInfoByClientIDInClientInfoDB() в классе LoadActualInfoFromClientInfoDB.

Пример POST-запроса:
	
	{
		“ClientID”: “1000010827”
	}
	
Пример ответа, что запрос взять в работу:
	
	{
		“PostStatus”: 1
	}


Пример ответа на GET-запрос:
	
	{
		{
			“ClientID”: “1000010827”,
			“FIO”: “Иванов Иван Иванович”,
			“Birthdate”: “15.03.1985”,
			“Document”: “4100 254313”,
			“Address”: “Российская Федерация, Москва г., Энтузиастов ш., 37, 101”,
			“Telephon”: “89291234567”,
			“AccountNumber”: “40817810500000012345”,
			“Rest”: “15000”,
			“DateRest”: “04.07.2021”,
			“CreditNumber”: “21/102/223344”,
			“CreditAmount”: “235000”,
			“CreditDate”: “01.03.2021”,
			“DepositNumber”: “20/602345”,
			“DepositAmount”: “80000”,
			“DepositDate”: “14.05.2020”
		}
	} 

# Задание с выбором паттерна для интерфейса.
Моя задумка первоначально должна была быть без GUI интерфейса. Потому как я думал реализовать доступ к сервису через REST и обращаться к нему из другого ПО.
Но поскольку от нас треьуется по заданию добавить интерфейс, сделаю это немного хитрым способом:
- Описанный ранее класс InfoClient и его вызовы LoadClientInfo, LoadAccountInfo, LoadCreditInfo, LoadDepositInfo - будут выполнять роль **Controller**
- Описанные ранее классы по получению и сохранению данных, SaveClientInfo, SaveAccountInfo, SaveCreditInfo, SaveDepositInfo - будут выполнять роль **Model**
- Описанный ранее класс LoadActualInfoFromClientInfoDB будет являться для моего приложения **View**

Представим задачу так: Пользователь инициирует получение данных по клиенту имея идентификатор клиента из внешней системы. Этот идентификатор передается по REST запросу из внешней системы. Мое приложение берет в обработку ID клиента и собирает всю необходимую информацию. Готовит ее к показу. Далее у пользователя прогружается информация на экране в интерфейсе внешнего приложения с полученной информаций. Таким образом я буду в рамках класса LoadActualInfoFromClientInfoDB подготавливать данные к отображению для пользователя во внешней системе.

# P.S. Напоминаю, что не работаю программистом. Не судите пожалуйста строго.